This is a set of solutions to three problems given by google for their Kickstart in July 2021.
These are all written in C++ in Notepad. Below are the problems provided by google which describes
the input and the ouput of the program.


The Two problems are listed below:

Problem 1:
You are given a 3×3 grid of integers. Let Gi,j denote the integer in the i-th row and j-th column of the grid, where i and j are 0-indexed. The integer in the middle of the grid, G1,1, is missing. Find the maximum number of rows, columns, and diagonals of this square, that form sequences which are arithmetic progressions. You can replace the missing number with any integer.

An arithmetic progression (also known as arithmetic sequence) is a sequence of numbers such that the difference between consecutive terms is constant. In mathematical terms, this can be represented as an=an−1+d, where d is the common difference. In this problem, a sequence can be the 3 numbers in either a row, column or diagonal. We are looking to replace the missing value by an integer that maximizes the number of arithmetic progressions that can be found in the resulting set of sequences.

Two sequences are considered different if they are from different rows, columns, or diagonals. For example, the sequence {2,4,6} across the middle row and {2,4,6} across the top row will be counted as two sequences but the sequences {2,4,6} and {6,4,2} across the same row, column, or diagonal will be counted as one sequence.

Input
The first line of the input gives the number of test cases, T. T test cases follow.
Each test case consists of 3 lines.
The first line of each test case contains 3 integers, G0,0, G0,1, and G0,2.
The second line of each test case contains 2 integers, G1,0 and G1,2.
The last line of each test case contains 3 integers, G2,0, G2,1, and G2,2.
Output
For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum possible number of arithmetic progressions that can be generated by the rows, columns, and diagonals of the grid after setting the missing element.



Problem 2:
You are given N intervals. An interval can be represented by two positive integers Li and Ri - the interval starts at Li and ends at Ri, represented as [Li,Ri]. Intervals may not be unique, so there might be multiple intervals with both equal Li and equal Ri.

You are allowed to perform a maximum of C cuts. A cut at X will cut all intervals [L,R] for which L<X and X<R. Cutting an interval at X is defined as splitting the interval into two intervals - [L,X] and [X,R]. Note that cuts can only be performed at integer points. Also, cutting at an endpoint of an interval (X=L or X=R) has no effect and does not split the interval.

You need to find the maximum number of intervals that can be obtained through a maximum of C cuts.

Input
The first line of the input contains the number of test cases, T. T test cases follow.

Each test case starts with a line containing two integers, N and C, denoting the number of intervals and the maximum number of cuts you can perform respectively. N lines follow.
The i-th line contains two integers Li and Ri, describing the i-th interval.

Output
For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum number of intervals that can be obtained through at most C cuts, as described above.



Problem 3:
It's time for the final exam in algorithms and data structures!

Edsger prepared N sets of problems. Each set consists of problems in an increasing difficulty sequence; the i-th set can be described by two integers Ai and Bi (Ai≤Bi), which denotes that this set contains problems with difficulties Ai,Ai+1,…,Bi. Among all problems from all sets, it is guaranteed that no two problems have the same difficulty.

This semester Edsger has to test M students. He wants to test each student with exactly one problem from one of his sets. No two students can get the exact same problem, so when Edsger tests a student with some problem, he cannot use this problem anymore. Through countless lectures, exercises, and projects, Edsger has gauged student number j to have skill level Sj, and wants to give that student a problem with difficulty Sj. Unfortunately, this is not always possible, as Edsger may have not prepared a problem of this difficulty, or he may have already asked this problem to some other student earlier. Therefore, Edsger will choose for the j-th student a problem of difficulty Pj, in a way that |Pj−Sj| is minimal and a question of difficulty Pj was not already given to any of the students before the j-th student. In case of ties, Edsger will always choose the easier problem. Note that the problem chosen for the j-th student may affect problems chosen for all the students tested later, so you have to process students in the same order as they appear in the input.

As keeping track of all the problems can be fairly complicated, can you help Edsger and determine which problems he should give to all of his students?

Input
The first line of the input gives the number of test cases, T. T test cases follow.

Each test case begins with a line which contains two integers N and M: the number of problem sets, and the number of students, respectively. N lines follow, describing the problem sets. Each of these N lines consists of two integers Ai and Bi denoting the easiest and the hardest problem in the i-th problem set. Finally, the test case ends with a single line with M integers S1,S2,…,SM denoting students' skill levels in the order they will be tested.

Output
For each test case, output one line containing Case #x: P1P2…PM, where x is the test case number (starting from 1) and Pj is a difficulty of a problem that will be given to the j-th student.
